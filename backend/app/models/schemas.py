from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, timezone
from enum import Enum


class Urgency(str, Enum):
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"


class IssueCategory(str, Enum):
    MAINTENANCE = "Maintenance"
    BILLING = "Billing"
    SECURITY = "Security"
    DELIVERIES = "Deliveries"
    AMENITIES = "Amenities"


class Intent(str, Enum):
    SOLVE_PROBLEM = "solve_problem"
    HUMAN_ESCALATION = "human_escalation"
    ANSWER_QUESTION = "answer_a_question"


class Status(str, Enum):
    SUBMITTED = "Submitted"
    PROCESSING = "Processing"
    IN_PROGRESS = "In Progress"
    RESOLVED = "Resolved"
    ESCALATED = "Escalated"


class HealthCheck(BaseModel):
    status: str
    service: str


class MessageRequest(BaseModel):
    resident_id: str = Field(..., description="Resident identifier")
    message_text: str = Field(..., description="Freeform text message from resident")
    timestamp: Optional[datetime] = Field(default_factory=datetime.now)
    category: Optional[IssueCategory] = Field(None, description="Optional category override")
    urgency: Optional[Urgency] = Field(None, description="Optional urgency override")


class ClassificationResponse(BaseModel):
    category: IssueCategory
    urgency: Urgency
    intent: Intent
    confidence: float = Field(..., ge=0.0, le=1.0)
    message_text: Optional[str] = Field(None, description="Original message text for risk prediction")



class RiskPredictionResponse(BaseModel):
    risk_forecast: float = Field(..., ge=0.0, le=1.0, description="Risk score (0-1)")
    recurrence_probability: Optional[float] = Field(None, ge=0.0, le=1.0)


class SimulatedOption(BaseModel):
    """Represents a simulated option/action generated by the simulation agent."""
    option_id: str = Field(..., description="Unique identifier for this option")
    action: str = Field(..., description="Description of the action to take")
    estimated_cost: float = Field(..., ge=0, description="Estimated cost in dollars")
    estimated_time: float = Field(..., ge=0, description="Estimated time to resolution in hours")
    reasoning: str = Field(..., description="Explanation for why this option was simulated")
    source_doc_ids: Optional[List[str]] = Field(None, description="KB document IDs used to generate this option (RAG Phase 1)")
    resident_satisfaction_impact: Optional[float] = Field(None, ge=0.0, le=1.0, description="Estimated resident satisfaction (0-1)")
    steps: Optional[List[str]] = Field(None, description="Brief action steps (3-5 steps) that will be taken")
    
    model_config = {"exclude_none": False}  # Always include all fields even if None


class SimulationResponse(BaseModel):
    options: List[SimulatedOption]
    issue_id: str


class PolicyWeights(BaseModel):
    urgency_weight: float = Field(0.4, ge=0.0, le=1.0, description="Weight for urgency in decision scoring")
    cost_weight: float = Field(0.3, ge=0.0, le=1.0, description="Weight for cost in decision scoring")
    time_weight: float = Field(0.2, ge=0.0, le=1.0, description="Weight for resolution time in decision scoring")
    satisfaction_weight: float = Field(0.1, ge=0.0, le=1.0, description="Weight for resident satisfaction in decision scoring")


class CostAnalysis(BaseModel):
    option_id: str
    estimated_cost: float
    exceeds_scale: bool
    scaled_cost: float

class TimeAnalysis(BaseModel):
    option_id: str
    estimated_time: float
    exceeds_scale: bool
    scaled_time: float

class DecisionReasoning(BaseModel):
    chosen_action: str = Field(..., description="The selected action to take")
    policy_scores: Dict[str, float] = Field(..., description="Scores for each option considered")
    considerations: List[str] = Field(..., description="List of all options considered with their scores")
    escalation_reason: Optional[str] = Field(None, description="Reason for escalation if applicable")
    cost_analysis: List[CostAnalysis] = Field(..., description="Cost analysis for business review")
    time_analysis: List[TimeAnalysis] = Field(..., description="Time analysis for business review")
    total_estimated_cost: float = Field(..., description="Total cost of chosen option")
    total_estimated_time: float = Field(..., description="Total time of chosen option")
    exceeds_budget_threshold: bool = Field(..., description="Indicates if any options exceed the cost scale")
    exceeds_time_threshold: bool = Field(..., description="Indicates if any options exceed the time scale")


class PolicyConfiguration(BaseModel):
    max_cost: float = Field(1000.0, gt=0.0, description="Maximum cost threshold for scaling calculations")
    max_time: float = Field(72.0, gt=0.0, description="Maximum resolution time in hours")


class DecisionResponse(BaseModel):
    chosen_action: str
    chosen_option_id: str
    reasoning: str
    alternatives_considered: List[str]
    policy_scores: Optional[Dict[str, float]] = None
    escalation_reason: Optional[str] = None
    rule_sources: Optional[List[str]] = Field(None, description="KB document IDs of policies/rules used (RAG Phase 1)")
    rule_object: Optional[Dict[str, Any]] = Field(None, description="Structured policy rule details retrieved from KB (RAG Phase 1)")


class DecisionRequest(BaseModel):
    """
    Request model for decision making endpoint.
    """
    classification: ClassificationResponse = Field(
        ...,
        description="Classification results including category, urgency, and intent"
    )
    simulation: SimulationResponse = Field(
        ...,
        description="Simulated options for resolving the issue"
    )
    weights: PolicyWeights = Field(
        default=PolicyWeights(),
        description="Custom weights for decision factors (optional)"
    )
    config: PolicyConfiguration = Field(
        default=PolicyConfiguration(),
        description="Configuration for cost and time thresholds (optional)"
    )


class DecisionResponseWithStatus(DecisionResponse):
    """
    Enhanced decision response with status information.
    """
    request_id: str = Field(default_factory=lambda: f"dec_{datetime.now().strftime('%Y%m%d%H%M%S')}")
    timestamp: datetime = Field(default_factory=datetime.now)
    status: str = Field(default="success")
    processing_time: float = Field(default=0.0)


class ResidentRequest(BaseModel):
    request_id: str
    resident_id: str
    message_text: str
    category: IssueCategory
    urgency: Urgency
    intent: Intent
    status: Status
    risk_forecast: Optional[float] = None
    classification_confidence: Optional[float] = None
    simulated_options: Optional[List[Dict]] = None  # Store all simulation options
    recommended_option_id: Optional[str] = None  # AI-recommended option
    user_selected_option_id: Optional[str] = None  # User's actual choice
    chosen_action: Optional[str] = None
    chosen_option_id: Optional[str] = None
    resolution_notes: Optional[str] = None  # Notes when marking resolved
    resolved_by: Optional[str] = None  # Who resolved it (admin/resident)
    resolved_at: Optional[datetime] = None  # When it was resolved
    created_at: datetime
    updated_at: datetime


class AdminRequestResponse(BaseModel):
    requests: List[ResidentRequest]
    total_count: int


class SelectOptionRequest(BaseModel):
    """Request model for resident selecting an option"""
    request_id: str = Field(..., description="Request ID")
    selected_option_id: str = Field(..., description="Option ID chosen by user")


class ResolveRequestModel(BaseModel):
    """Request model for marking a request as resolved"""
    request_id: str = Field(..., description="Request ID to resolve")
    resolution_notes: Optional[str] = Field(None, description="Optional notes about resolution")
    resolved_by: str = Field(..., description="Who resolved it: 'admin' or 'resident'")


# ============================================================================
# RAG (RETRIEVAL-AUGMENTED GENERATION) MODELS (Phase 1)
# ============================================================================

class DocumentChunk(BaseModel):
    """
    Represents a chunk of a knowledge base document with metadata.
    Used for storing and retrieving document segments from vector store.
    """
    doc_id: str = Field(..., description="Unique document identifier from KB metadata")
    chunk_id: str = Field(..., description="Unique identifier for this specific chunk")
    text: str = Field(..., description="The actual text content of the chunk")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Document metadata (type, category, building_id, etc.)")
    embedding_id: Optional[str] = Field(None, description="Vector store embedding ID if persisted")
    
    class Config:
        json_schema_extra = {
            "example": {
                "doc_id": "policy_noise_1.0",
                "chunk_id": "policy_noise_1.0_chunk_0",
                "text": "Quiet hours are 10 PM to 8 AM. Violations may result in warnings...",
                "metadata": {
                    "type": "policy",
                    "category": "community",
                    "building_id": "all_buildings",
                    "effective_date": "2024-01-01",
                    "version": "1.0"
                },
                "embedding_id": "vec_123abc"
            }
        }


class RetrievalContext(BaseModel):
    """
    Contains retrieved documents and metadata from RAG retrieval operation.
    Provides context for LLM prompts in simulation and decision agents.
    """
    query: str = Field(..., description="Original query text used for retrieval")
    retrieved_docs: List[Dict[str, Any]] = Field(..., description="List of retrieved documents with text, metadata, and scores")
    total_retrieved: int = Field(..., ge=0, description="Number of documents retrieved")
    retrieval_timestamp: datetime = Field(default_factory=datetime.now, description="When retrieval occurred")
    retrieval_method: str = Field(default="similarity_search", description="Method used (similarity_search, mmr, etc.)")
    
    class Config:
        json_schema_extra = {
            "example": {
                "query": "What is the policy for noise complaints?",
                "retrieved_docs": [
                    {
                        "doc_id": "policy_noise_1.0",
                        "text": "Quiet hours are 10 PM to 8 AM...",
                        "score": 0.89,
                        "metadata": {"type": "policy", "category": "community"}
                    }
                ],
                "total_retrieved": 3,
                "retrieval_timestamp": "2024-11-09T12:34:56",
                "retrieval_method": "similarity_search"
            }
        }


class RAGOption(BaseModel):
    """
    Extended simulation option that includes KB source citations.
    Used by simulation agent when RAG is enabled.
    """
    option: SimulatedOption = Field(..., description="The base simulated option")
    retrieval_context: Optional[RetrievalContext] = Field(None, description="RAG retrieval context used to generate this option")
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0, description="Confidence in option based on KB match quality")
    
    class Config:
        json_schema_extra = {
            "example": {
                "option": {
                    "option_id": "opt_1",
                    "action": "Send noise complaint warning to resident in Unit 302",
                    "estimated_cost": 0.0,
                    "estimated_time": 0.5,
                    "reasoning": "Based on noise complaint policy...",
                    "source_doc_ids": ["policy_noise_1.0"]
                },
                "retrieval_context": {
                    "query": "noise complaint at night",
                    "retrieved_docs": [{"doc_id": "policy_noise_1.0", "score": 0.89}],
                    "total_retrieved": 2
                },
                "confidence_score": 0.89
            }
        }


class RuleContext(BaseModel):
    """
    Structured representation of policy rules retrieved from KB.
    Used by decision agent for rule-based decision making.
    """
    rule_id: str = Field(..., description="Unique identifier for the rule")
    rule_text: str = Field(..., description="The actual rule/policy text")
    source_docs: List[str] = Field(..., description="KB document IDs where this rule is defined")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in rule applicability")
    policy_section: Optional[str] = Field(None, description="Section/category of the policy")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional rule metadata")
    
    class Config:
        json_schema_extra = {
            "example": {
                "rule_id": "noise_quiet_hours",
                "rule_text": "Quiet hours are enforced from 10 PM to 8 AM. First violation results in written warning.",
                "source_docs": ["policy_noise_1.0"],
                "confidence": 0.92,
                "policy_section": "community_standards",
                "metadata": {"severity": "medium", "escalation_threshold": 3}
            }
        }

